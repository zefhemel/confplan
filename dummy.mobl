module dummy

import data

function loadGpce() {
  var conf = Conference(name="GPCE");
  add(conf);

  // Sunday
  conf.events.add(Event(name="Registration", startDate=DateTime.create(2010, 9, 10, 8, 30)));
  conf.events.add(Event(name="Opening", startDate=DateTime.create(2010, 9, 10, 8, 50)));
  conf.events.add(Event(name="Tutorial 1: Project Fortress: A Growable Language for Scientists and Engineers", speaker="Sukyoung Ryu", abstract="We can think of a programming language as a vocabulary of words and a set of rules that define how to combine words into meaningful constructs. Creating a vocabulary and a set of rules that allow programmers to express their ideas clearly and concisely is one of the main goals of language design. However, it is difficult to anticipate the vocabulary and the set of rules that are suitable for solving various problems. It often depends on domain-specific applications, new hardware platforms, and any unexpected feature requests. Therefore, a language should grow over time to accommodate the changing needs of its users.", startDate=DateTime.create(2010, 9, 10, 9, 0)));
  conf.events.add(Event(name="Break", startDate=DateTime.create(2010, 9, 10, 10, 0)));
  conf.events.add(Event(name="Tutorial 2: Mega-Modeling Software Language Artifacts", speaker="Jean-Marie Favre, Dragan Gasevic, Ralf Laemmel", abstract="Modern software is typically made of heterogeneous sets of software artifacts including for instance databases, programs, transformations, grammars, models and metamodels, compilers, interpreters, formats, ontologies, frameworks, APIs, schemas, configuration files, makefiles, etc. In practice particular languages, tools, implementations, and standards are used such as SQL DDL, Saxon, XLST, Java, Hibernate, XSD, OWL, DOM, Antlr, UML, XMI, Ecore, Awk, and so on. In the absence of a conceptual framework it is difficult to understand the relationships between these software artifacts, if any. The goal of this tutorial is to provide such a framework, showing that the similarity and relationships between techniques can be modeled at a high level of abstraction, and even more importantly that recurring patterns occur in such models. Some of these patterns, for instance those involving \"bridges\" between technologies, would be really difficult to grasp without a proper conceptualization. As a result software engineers and researchers usually find it hard to understand the intricacies of technologies that are out of their area of expertise and it is more than likely that they do not realize the analogies that exist between heterogeneous technologies. This tutorial aims to unveil these recurring patterns and to show participants coming from different horizons how to model the technologies they design or work with in an uniform way and how to situate them into the overall software language landscape.", startDate=DateTime.create(2010, 9, 10, 10, 30)));
  conf.events.add(Event(name="Tutorial 3: Embedded Domain-Specific Language Implementation using Dependent Types", speaker="Edwin Brady", abstract="Domain-specific languages (DSLs) are programming languages designed for solving problems in a particular domain. By providing suitable abstractions, they allow experts to focus on solving high-level problems without being concerned with low-level programming details. Embedded domain-specific languages (EDSLs) are an emerging implementation technique, in which features of a host language, for example parsing or code generation, are exploited by the DSL implementation. In this way, EDSLs can be implemented much more rapidly than their standalone equivalents and can take advantage of compiler optimisations and other implementation effort in the host.", startDate=DateTime.create(2010, 9, 10, 11, 30)));
  conf.events.add(Event(name="Lunch", startDate=DateTime.create(2010, 9, 10, 12, 30)));
  conf.events.add(Event(name="Tutorial 4: Agile and Efficient Domain-Specific Languages using Multi-Stage Programming in Java Mint", speaker="Mathias Ricken, Edwin Westbrook, Walid Taha", abstract="Domain-specific languages (DSLs) are a powerful productivity tool because they allow domain experts, who are not necessarily programming experts, to quickly develop programs. DSL implementations have unique constraints for programming languages because they must be efficient, in order to ensure high productivity, but they must also be agile, in order to meet the rapidly changing demands of their domains. In this tutorial we show how multi-stage programming (MSP) can be used to build staged interpreters, which combine the agility of interpreters with the efficiency of compilers. The tutorial is conducted in Java Mint, an multi-stage Java based on recent work incorporating MSP into imperative object-oriented languages. In the first half of the tutorial, we introduce MSP by demonstrating how to write a staged interpreter for a number of basic language constructs, such as recursive functions, conditionals, and let expressions. In the second half, we extend our staged interpreter to take advantage of several well-known compiler optimizations, including type inference, constant folding, and static parallel loop scheduling. We highlight the opportunities afforded by using MSP with object-oriented design to quickly create efficient DSL implementations.", startDate=DateTime.create(2010, 9, 10, 13, 30)));
  conf.events.add(Event(name="Tutorial 5: Ontologies and Software Language Engineering", speaker="Dragan Gasevic, Fernando Silva Parreiras, Tobias Walter", abstract="Trying to advance the current practices for sharing data, resources and knowledge on the Web, the research community has been researching challenges around the idea of the Semantic Web. The central component of the Semantic Web are ontologies, commonly defined as formal and explicit definitions of shared domain conceptualizations. To have an interoperable and standardized set of technologies, the Semantic Web research offered a stack of standards and tools including automated reasoners and ontology languages, i.e., languages to describe formally a domain of discourse. This stack of standards and tools is popularly called semantic technologies. Among ontology languages, the Web Ontology Language (OWL) [4] is the most prominent.", startDate=DateTime.create(2010, 9, 10, 14, 30)));
  conf.events.add(Event(name="Break", startDate=DateTime.create(2010, 9, 10, 15, 30)));
  conf.events.add(Event(name="Tutorial 6: Language Definition and Extension with MPS", speaker="Markus Voelter", abstract="Language definition and extension is a hot topic. Using modular languages, where a program can use concepts from different language modules as needed, promises significantly increased language usability as well as an integration between general purpose (programming) and domain-specific (modeling) concepts and tools.  JetBrains MPS is an open source language workbench that uses projectional editing as opposed to parsing techniques. In MPS, languages are defined via structure, projection rules, transformation rules and type systems.  In this tutorial I will provide a brief overview about how MPS works and what you can do with it. I will show how to build an external DSL, how to integrate the external DSL with Java, and how to extend an existing programming language with a new statement. To round it off, I will demo a non-trivial set of languages for embedded software development. 90% of the tutorial will be live demos.  Note that even if you don't plan to work with MPS specifically, this tutorial will provide a good overview of projectional editing.", startDate=DateTime.create(2010, 9, 10, 16, 0)));
  conf.events.add(Event(name="End", startDate=DateTime.create(2010, 9, 10, 17, 0)));

  // Monday
  conf.events.add(Event(name="Opening", startDate=DateTime.create(2010, 9, 11, 8, 45)));
  conf.events.add(Event(name="Keynote: The Hitchhiker's Guide to Software Languages", speaker="Ralf Laemmel", abstract="There is only that much space in the CS curriculum, and there are always new subjects that should be accommodated by the curriculum. For instance, in our community, we would want all graduates to leave university with a modest background in technical spaces, software languages, and meta-programming; also, with conceptually informed and reasonably timeless skills to efficiently master related programming techniques and technologies. In reality, the curricula of few CS departments meet this expectation. In this talk, I will discuss such curricula-related expectations of our community and the suboptimal situation at CS departments - as I perceive them. More importantly, I will allude to a revision of the CS curriculum that could optimize matters and may stand a chance for mid-term adoption.", startDate=DateTime.create(2010, 9, 11, 9, 0)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 11, 10, 0)));
  conf.events.add(Event(name="Abstract Delta Modeling", speaker="Dave Clarke, Michiel Helvensteijn and Ina Schaefer", abstract="Delta modeling is an approach to facilitate automated product derivation for software product lines. It is based on a set of deltas specifying modifications that are incrementally applied to a core product. The applicability of deltas depends on feature-dependent conditions. This paper presents abstract delta modeling, which explores delta modeling from an abstract, algebraic perspective. Compared to previous work, we take a more flexible approach with respect to conflicts between modifications and introduce the notion of conflict resolving deltas. We present conditions on the structure of deltas to ensure unambiguous product generation.", startDate=DateTime.create(2010, 9, 11, 10, 30)));
  conf.events.add(Event(name="Automatic Variation-Point Identification in Function-Block-Based Models", speaker="Uwe Ryssel, Joern Ploennigs and Klaus Kabitzsch", abstract="Function-block-based modeling is often used to develop embedded systems, particularly as system variants can be developed rapidly from existing modules. Generative approaches can simplify the handling and development of the resulting high variety of function-block-based models. But they often require the development of new generic models that do not utilize existing ones. Reusing existing models will significantly decrease the effort to apply generative programming. This work introduces an automatic approach to recognize variants in a set of models and identify the variation points and their dependencies within the variants. As result it offers automatically generated feature models and ICCL content to generate the given variants.", startDate=DateTime.create(2010, 9, 11, 11, 0)));
  conf.events.add(Event(name="Efficient Extraction and Analysis of Preprocessor-Based Variability", speaker="Julio Sincero, Reinhard Tartler, Daniel Lohmann and Wolfgang Schršder-Preikschat", abstract="The CPP is the dominant tool of choice for the implementation of variability in large-scale configurable software. Linux, probably the most-configurable piece of software ever, employs more than 10,000 preprocessor variables for this purpose. However, this de-facto variability tends to be ``hidden in the code''; which on the long term leads to varibility defects, such as dead code or inconsistencies with respect to the intended (modelled) variability of the software. This calls for tool support for the efficient extraction of (and reasoning over) CPP-based variability.", startDate=DateTime.create(2010, 9, 11, 11, 30)));
  conf.events.add(Event(name="Lunch", startDate=DateTime.create(2010, 9, 11, 12, 0)));
  conf.events.add(Event(name="Iterative Type Inference with Attribute Grammars", speaker="Arie Middelkoop, S. Doaitse Swierstra and Atze Dijkstra", abstract="Type inference is the process of constructing a typing derivation while gradually discovering type information. During this process, inference algorithms typically make subtle decisions based on the derivation constructed so far.  Because a typing derivation is a decorated tree we aim to use attribute grammars as the main implementation tool. Unfortunately, we can neither express iteration, nor express decisions based on intermediate derivations in such grammars.  Here, we present the language |rulerfront|, a conservative extension to ordered attribute grammars, that deals with the aforementioned problems. We show why this extension is suitable for the description of constraint-based inference algorithms.", startDate=DateTime.create(2010, 9, 11, 13, 30)));
  conf.events.add(Event(name="Automatic and Efficient Simulation of Operation Contracts", speaker="Matthias P. Krieger, Alexander Knapp and Burkhart Wolff", abstract="Operation contracts consisting of pre- and postconditions are a well-known means of specifying operations. In this paper we deal with the problem of operation contract simulation, i.e. determining operation results satisfying the postconditions based on input data supplied by the user; simulating operation contracts is an important technique for requirements validation and prototyping. Current approaches to operation contract simulation exhibit poor performance for large sets of input data or require additional guidance from the user. We show how these problems can be alleviated and describe an efficient as well as fully automatic approach. It is implemented in our tool OCLexec that generates from UML/OCL operation contracts corresponding Java implementations which call a constraint solver at runtime. The generated code can serve as a prototype. A case study demonstrates that our approach can handle problem instances of considerable size.", startDate=DateTime.create(2010, 9, 11, 14, 0)));
  conf.events.add(Event(name="Implicit Invocation Meets Safe, Implicit Concurrency", speaker="Yuheng Long, Sean Mooney, Tyler Sondag and Hridesh Rajan", abstract="Writing correct and efficient concurrent programs still remains a challenge. Explicit concurrency is difficult, error prone, and creates code which is hard to maintain and debug. This type of concurrency also treats modular program design and concurrency as separate goals, where modularity often suffers.  To solve these problems, we are designing a new language that we call Panini. In this paper, we focus on Panini's asynchronous, typed events, which reconcile the modularity goal promoted by the implicit invocation design style with the concurrency goal of exposing potential concurrency between the execution of subjects and observers.  Since modularity is improved and concurrency is implicit in Panini, programs are easier to reason about and maintain. Furthermore, races and deadlocks are avoided entirely, yielding programs with a guaranteed sequential semantics.  To evaluate our language design and implementation we show several examples of its usage as well as an empirical study of program performance.  We found that not only is developing and understanding Panini programs significantly easier compared to standard concurrent object-oriented programs, but performance of Panini programs is also comparable to their equivalent hand-tuned versions written using Java's fork-join framework.", startDate=DateTime.create(2010, 9, 11, 14, 30)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 11, 15, 0)));
  conf.events.add(Event(name="A Component-based Run-time Evolution Infrastructure for Resource-Constrained Embedded Systems", speaker="Juan F. Navas, Jean-Philippe Babau and Jacques Pulou", abstract="This paper deals with embedded systems software and the modification of its architecture and behavior at execution-time. Incautious implementation of such capabilities demands heavy memory and performance overrun. To accomplish such software evolution activities in resource-constrained embedded systems, we propose a component-based run-time evolution infrastructure that reconciles richness of evolution alternatives and performance requirements. Our proposition is based on off-site components reifications, representations of components which allow us to treat evolution concerns remotely and hence to alleviate the workload to be processed by the embedded device. Memory and processor-time resources consumption evaluation on a real-world scenario show the efficiency and pertinence of our approach.", startDate=DateTime.create(2010, 9, 11, 15, 30)));
  conf.events.add(Event(name="Modular Domain-Specific Language Components in Scala", speaker="Christian Hofer and Klaus Ostermann", abstract="Programs in domain-specific embedded languages (DSELs) can be represented in the host language in different ways, for instance implicitly as libraries, or explicitly in the form of abstract syntax trees. Each of these representations has its own strengths and weaknesses. The implicit approach has good composability properties, whereas the explicit approach allows more freedom in making syntactic program transformations. Traditional designs for DSELs fix the form of representation, which means that it is not possible to choose the best representation for a particular interpretation or transformation. We propose a new design for implementing DSELs in Scala which makes it easy to use different program representations at the same time. It enables the DSL implementor to define modular language components and to compose transformations and interpretations for them.", startDate=DateTime.create(2010, 9, 11, 16, 0)));
  conf.events.add(Event(name="Adding Genericity to a Plug-in Framework", speaker="Reinhard Wolfinger, Markus Loeberbauer, Markus Jahn and Hanspeter Moessenboeck", abstract="Plug-in components are a means for making feature-rich applications customizable. Combined with plug-and-play composition, end users can assemble customized applications without programming. If plug-and-play composition is also dynamic, applications can be reconfigured on the fly to load only components the user needs for his current work. We have created Plux.NET, a plug-in framework that supports dynamic plug-and-play composition. The basis for plug-and-play in Plux is the composer which replaces programmatic composition by automatic composition. Components just specify their requirements and provisions using metadata. The composer then assembles the components based on that metadata by matching requirements and provisions. When the composer needs to reuse general-purpose components in different parts of an application, the component model requires genericity. The composer depends on metadata that specify which components should be connected and for general-purpose components those metadata need to be different on each reuse. We present an approach for generic plug-ins with component templates and an implementation for Plux. The general-purpose components become templates and the templates get parameterized when they are composed.", startDate=DateTime.create(2010, 9, 11, 16, 30)));
  conf.events.add(Event(name="Reception", startDate=DateTime.create(2010, 9, 11, 17, 30)));

  // Tuesday
  conf.events.add(Event(name="Opening", startDate=DateTime.create(2010, 9, 12, 8, 45)));
  conf.events.add(Event(name="Keynote: A Language for Software Variation Research", speaker="Martin Erwig", abstract="Managing variation is an important problem in software engineering that takes different forms, ranging from version control and configuration management to software product lines. In this talk, I present our recent work on the choice calculus, a fundamental representation for software variation that can serve as a common language of discourse for variation research, filling a role similar to lambda calculus in programming language research. After motivating the design of the choice calculus and sketching its semantics, I will discuss several potential application areas.", startDate=DateTime.create(2010, 9, 12, 9, 0)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 12, 10, 0)));
  conf.events.add(Event(name="Code Clones in Feature-Oriented Software Product Lines", speaker="Sandro Schulze, Sven Apel and Christian Kaestner", abstract="Some limitations of object-oriented mechanisms are known to cause code clones (e.g., extension using inheritance). Novel programming paradigms such as feature-oriented programming (FOP) aim at alleviating these limitations. However, it is an open issue whether FOP is really able to avoid code clones or whether it even facilitates (FOP-specific) clones. To address this issue, we conduct an empirical analysis on ten feature-oriented software product lines with respect to code cloning. We found that there is a considerable amount of clones in feature-oriented software product lines and that a large fraction of these clones is FOP-specific (i.e., caused by limitations of feature-oriented mechanisms). Based on our results, we initiate a discussion on the reasons for FOP-specific clones and on how to cope with them.", startDate=DateTime.create(2010, 9, 12, 10, 30)));
  conf.events.add(Event(name="Composition of Dynamic Analysis Aspects", speaker="Eric Tanter, Philippe Moret, Walter Binder and Danilo Ansaloni", abstract="Aspect-oriented programming provides a convenient high-level model to define several kinds of dynamic analyses, in particular thanks to recent advances in exhaustive weaving in core libraries. Casting dynamic analyses as aspects allows the use of a single weaving infrastructure to apply different analyses to the same base program, simultaneously. However, even if dynamic analysis aspects are mutually independent, their mere presence perturbates the observations of others: this is due to the fact that aspectual computation is potentially visible to all aspects. Because current aspect composition approaches do not address this kind of computational interference, combining different analysis aspects yields at best unpredictable results. It is also impossible to flexibly combine various analyses, for instance to analyze an analysis aspect. In this paper we show how the notion of execution levels makes it possible to effectively address these composition issues. In order to realize this approach, we explore the practical and efficient integration of execution levels in a mainstream aspect language, AspectJ. We report on a case study of composing two out-of-the-box analysis aspects in a variety of ways, highlighting the benefits of the approach.", startDate=DateTime.create(2010, 9, 12, 11, 0)));
  conf.events.add(Event(name="Applications of Dynamic Code Evolution for Java in GUI Development and Dynamic Aspect-Oriented Programming", speaker="Thomas Wuerthinger, Walter Binder, Danilo Ansaloni, Philippe Moret and Hanspeter Moessenboeck", abstract="While dynamic code evolution in object-oriented systems is an important feature supported by dynamic languages, there is currently only limited support for dynamic code evolution in high-performance, state-of-the-art runtime systems for statically typed languages, such as the Java Virtual Machine. In this tool demonstration, we present the Dynamic Code Evolution VM, which is based on a recent version of Oracle's state-of-the-art Java HotSpot(TM) VM and allows unlimited changes to loaded classes at runtime. Based on the Dynamic Code Evolution VM, we developed an enhanced version of the Mantisse GUI builder (which is part of the NetBeans IDE) that allows adding GUI components without restarting the application under development. Furthermore, we redesigned the dynamic AOP framework HotWave to take advantage of the enhanced dynamic code evolution capabilities. The new version, HotWave2, now supports most AspectJ constructs, including \"around()\" advice and static cross-cutting. We will demonstrate both the enhanced Mantisse GUI builder as well as HotWave2, weaving several aspects for dynamic analysis in sizable applications at runtime.", startDate=DateTime.create(2010, 9, 12, 11, 30)));
  conf.events.add(Event(name="Lunch", startDate=DateTime.create(2010, 9, 12, 12, 0)));
  conf.events.add(Event(name="Lightweight Modular Staging: A Pragmatic Approach to Runtime Code Generation and Compiled DSLs", speaker="Tiark Rompf and Martin Odersky", abstract="Software engineering demands generality and abstraction, performance demands specialization and concretization. Generative programming can provide both, but developing high-quality program generators takes a large effort, even if a multi-stage programming language is used.  We present lightweight modular staging, a library-based multi-stage programming approach that breaks with the tradition of syntactic quasi-quotation and instead uses only types to distinguish between binding times. Through extensive use of component technology, lightweight modular staging makes an optimizing compiler framework available at the library level, allowing programmers to tightly integrate domain-specific abstractions and optimizations into the generation process.  We argue that lightweight modular staging enables a form of language virtualization, i.e. allows to go from a pure-library embedded language to one that is practically equivalent to a stand-alone implementation with only modest effort.", startDate=DateTime.create(2010, 9, 12, 13, 30)));
  conf.events.add(Event(name="Domain-specific Language Integration with Compile-time Parser Generator Library", speaker="Zoltan Porkolab and Abel Sinkovics", abstract="Smooth integration of domain-specific languages into a general purpose host language requires absorbing of domain code written in arbitrary syntax. The integration should cause minimal syntactical and semantic overhead and introduce minimal dependency on external tools. In this paper we discuss a DSL integration technique for the C++ programming language. The solution is based on compile-time parsing of the DSL code. The parser generator is a C++ template metaprogram reimplementation of a runtime Haskell parser generator library. The full parsing phase is executed when the host program is compiled. The library uses only standard C++ language features, thus our solution is highly portable. As a demonstration of the power of this approach, we present a highly efficient and type-safe version of printf and the way it can be constructed using our library. Despite the well known syntactical difficulties of C++ template metaprograms, building embedded languages using our library leads to self-documenting C++ source code.", startDate=DateTime.create(2010, 9, 12, 14, 0)));
  conf.events.add(Event(name="ABI Compatibility Through a Customizable Language", speaker="Atkinson, Matthew Flatt and Gary Lindstrom", abstract="ZL is a C++-compatible language in which high-level constructs, such as classes, are defined using macros over a C-like core language. This approach makes many parts of the language easily customizable. For example, since the class construct can be defined using macros, a programmer can have complete control over the memory layout of objects. Using this capability, a programmer can mitigate certain problems in software evolution such as fragile ABIs (Application Binary Interfaces) due to software changes and incompatible ABIs due to compiler changes. In this paper, we outline the problem of fragile and incompatible ABIs and show how ZL can be used to solve them.", startDate=DateTime.create(2010, 9, 12, 14, 30)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 12, 15, 0)));
  conf.events.add(Event(name="Model-based Kinematics Generation for Modular Mechatronic Toolkits", speaker="Mirko Bordignon, Ulrik P. Schultz and Kasper Stoy", abstract="Modular robots are mechatronic devices that enable the construction of highly versatile and flexible robotic systems that can dynamically modify their assembled mechanical structure. The key feature that enables this dynamic modification is the capability of the individual modules to connect to each other in multiple ways and thus generate a number of different mechanical systems, in contrast with the monolithic, fixed structure of conventional robots. The mechatronic flexibility, however, complicates the development of models and programming abstractions for modular robots, since manually describing and enumerating the full set of possible interconnections is tedious and error-prone for real-world robots.", startDate=DateTime.create(2010, 9, 12, 15, 30)));
  conf.events.add(Event(name="Incremental Type-Checking for Type-Reflective Metaprograms", speaker="Weiyu Miao and Jeremy Siek", abstract="Garcia introduces a calculus for type-reflective metaprogramming that provides much of the power and flexibility of C++ templates and solves many of its problems. However, one of the problems that remains is that the residual program is not type checked until after meta computation is complete. Ideally, one would like the type system of the metaprogram to also guarantee that the residual program will type check, as is the case in MetaML. However, in a language with type-reflective metaprogramming, type expressions in the residual program may be the result of meta computation, making the MetaML guarantee next to impossible to achieve.", startDate=DateTime.create(2010, 9, 12, 16, 0)));
  conf.events.add(Event(name="JEqualityGen: Generating equality and hashing methods", speaker="Neville Grech, Julian Rathke and Bernd Fischer", abstract="Manually implementing equals (for object comparisons) and hashCode (for object hashing) methods in large software projects is tedious and error-prone. This is due to many special cases, such as field shadowing, comparison between different types, or cyclic object graphs. Here, we present JEqualityGen, a source code generator that automatically derives implementations of these methods. JEqualityGen proceeds in two states: it first uses source code reflection in MetaAspectJ to generate aspects that contain the method implementations, before it uses weaving on the bytecode level to insert these into the target application. JEqualityGen generates not only correct, but efficient source code that on a typical large-scale Java application exhibits a performance improvement of more than two orders of magnitude in the equality operations generated, compared to an existing system based on runtime reflection. JEqualityGen achieves this by generating runtime profiling code that collects data. This enables it to generate optimised method implementations in a second round.", startDate=DateTime.create(2010, 9, 12, 16, 30)));
  conf.events.add(Event(name="Banquet at DAF Museum", startDate=DateTime.create(2010, 9, 12, 18, 0)));
}

function loadSle() {
  var conf = Conference(name="SLE");
  add(conf);

  // Tuesday
  conf.events.add(Event(name="Opening", startDate=DateTime.create(2010, 9, 12, 8, 45)));
  conf.events.add(Event(name="Keynote: A Language for Software Variation Research", speaker="Martin Erwig", abstract="Managing variation is an important problem in software engineering that takes different forms, ranging from version control and configuration management to software product lines. In this talk, I present our recent work on the choice calculus, a fundamental representation for software variation that can serve as a common language of discourse for variation research, filling a role similar to lambda calculus in programming language research. After motivating the design of the choice calculus and sketching its semantics, I will discuss several potential application areas.", startDate=DateTime.create(2010, 9, 12, 9, 0)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 12, 10, 0)));
  conf.events.add(Event(name="Automated Selective Caching for Reference Attribute Grammars", speaker="Emma Soederberg and Goerel Hedin", abstract="Reference attribute grammars (RAGs) can be used to express semantics as super-imposed graphs on top of abstract syntax trees (ASTs). A RAG-based AST can be used as the in-memory model providing semantic information for software language tools such as compilers, refactoring tools, and meta-modeling tools. RAG performance is based on dynamic attribute evaluation with caching. Caching all attributes gives optimal performance in the sense that each attribute is evaluated at most once. However, performance can be further improved by a selective caching strategy, avoiding caching overhead where it does not pay off. In this paper we present a profiling-based technique for automatically finding a good caching configuration. The technique has been evaluated on a generated Java compiler, compiling programs from the Jacks test suite and the DaCapo benchmark suite.", startDate=DateTime.create(2010, 9, 12, 10, 30)));
  conf.events.add(Event(name="Reference Attribute Grammars for Metamodel Semantics", speaker="Christoff Buerger, Sven Karol, Christian Wende and Uwe Assmann", abstract="While current metamodelling languages are well-suited for the structural definition of abstract syntax and metamodelling platforms like the Eclipse Modelling Framework (EMF) provide various means for the specification of a textual or graphical concrete syntax, techniques for the specification of model semantics are not as matured. Therefore, we propose the application of reference attribute grammars (RAGs) to alleviate the lack of support for formal semantics specification in metamodelling. We contribute the conceptual foundations to integrate metamodelling languages and RAGs, and present JastEMF --- a tool for the specification of EMF metamodel semantics using JastAdd RAGs. The presented approach is exemplified by an integrated metamodelling example. Its advantages, disadvantages and limitations are discussed and related to metamodelling, attribute grammars (AGs) and other approaches for metamodel semantics.", startDate=DateTime.create(2010, 9, 12, 11, 0)));
  conf.events.add(Event(name="Modelling GLL parser implementations", speaker="Adrian Johnstone and Elizabeth Scott", abstract="We describe the development of space-efficient implementations of GLL parsers, and the process by which we refine a set-theoretic model of the algorithm into a practical parser generator that creates practical parsers. GLL parsers are recursive descent-like, in that the structure of the parser's code closely mirrors the grammar rules, and so grammars (and their parsers) may be debugged by tracing the running parser in a debugger. While GLL recognisers are straightforward to describe, full GLL parsers present technical traps and challenges for the unwary. In particular, na•ve implementations based closely on the theoretical description of GLL can result in data structures that are not practical for grammars for real programming language grammars such as ANSI-C. We develop an equivalent formulation of the algorithm as a high-level set-theoretic model supported by table-based indices, in order to then explore a set of alternative implementations which trade space for time in ways which preserve the cubic bound.", startDate=DateTime.create(2010, 9, 12, 11, 30)));
  conf.events.add(Event(name="Lunch", startDate=DateTime.create(2010, 9, 12, 12, 0)));
  conf.events.add(Event(name="Metamodel Usage Analysis for identifying Metamodel Improvements", speaker="Markus Herrmannsdšrfer, Daniel Ratiu and Maximilian Koegel", abstract="Modeling languages raise the abstraction level at which software is built by providing a set of constructs tailored to the needs of their users. Metamodels define their constructs and thereby reflect the expectations of the language developers about the use of the language. In practice, language users often do not use the constructs provided by a metamodel as expected by language developers. In this paper, we advocate that insights about how constructs are used can offer language developers useful information for improving the metamodel. We define a set of usage and improvement patterns to characterize the use of the metamodel by the built models. We present our experience with the analysis of the usage of seven metamodels (EMF, GMF, UNICASE) and a large corpus of models. Our empirical investigation shows that we identify mismatches between the expected and actual use of a language that are useful for metamodel improvements.", startDate=DateTime.create(2010, 9, 12, 13, 30)));
  conf.events.add(Event(name="Domain-Specific Modelling Languages with Algebraic Graph Transformations on RDF", speaker="Benjamin Braatz and Christoph Brandt", abstract="Domain-specific modelling langugages (DSMLs), which are tailored to the requirements of their users, can significantly increase the acceptance of formal (or at least semi-formal) modelling in scenarios where informal drawings and natural language descriptions are predominant today. We show in this paper how the Resource Description Framework (RDF), which is a standard for the fundamental data structures of the Semantic Web, and algebraic graph transformations on these data structures can be used to realise the abstract syntax of such DSMLs. We examine a small DSML for IT infrastructures as an application scenario. From this scenario, we derive distributed modelling, evolution of language definitions, migration of legacy models and integration of modelling languages as key requirements for a DSML framework. RDF and transformation rules are then used to provide a solution, which meets these requirements, where all kinds of modifications -- from simple editing steps via model migration to language integration -- are realised by the single, uniform formalism of algebraic graph transformation.", startDate=DateTime.create(2010, 9, 12, 14, 0)));
  conf.events.add(Event(name="Feature and Meta-Models in Clafer: Mixed, Specialized, and Coupled", speaker="Kacper Bak, Krzysztof Czarnecki and Andrzej Wasowski", abstract="We present Clafer, a meta-modeling language with first-class support for feature modeling. We designed Clafer as a concise notation for meta-models, feature models, mixtures of meta- and feature models (such as components with options), and models that couple feature models and meta-models via constraints (such as mapping feature configurations to component configurations or model templates). Clafer also allows arranging models into multiple specialization and extension layers via constraints and inheritance. We identify four key mechanisms allowing a meta-modeling language to express feature models concisely and show that Clafer meets its design objectives using a sample product line. We evaluated Clafer and how it lends itself to analysis on sample feature models, meta-models, and model templates of an E-Commerce platform.", startDate=DateTime.create(2010, 9, 12, 14, 30)));
  conf.events.add(Event(name="Break", startDate=DateTime.create(2010, 9, 12, 15, 0)));
  conf.events.add(Event(name="Support for the Evolution of C++ Generic Functions", speaker="Peter Pirkelbauer, Damian Dechev and Bjarne Stroustrup", abstract="The choice of requirements for an argument of a generic type or algorithm is a central design issue in generic programming. In the context of C++, a specification of requirements for a template argument or a set of template arguments is called a concept. In this paper, we present a novel tool, TACE , designed to help programmers understand the requirements that their code de facto imposes on arguments and help simplify and generalize those through comparisons with libraries of well-defined and precisely-specified concepts. TACE automatically extracts requirements from the body of template functions. These requirements are expressed using the notation and semantics developed by the ISO C++ standards committee. TACE converts implied requirements into concept definitions and compares them against concepts from a repository. Components of a well-defined library exhibit commonalities that allow us to detect problems by comparing requirements from many components: Design and implementation problems manifest themselves as minor variations in requirements. TACE points to source code that cannot be constrained by concepts and to code where small modifications would allow the use of less constraining concepts. For people who use a version of C++ with concept support, TACE can serve as a core engine for automated source code rejuvenation.", startDate=DateTime.create(2010, 9, 12, 15, 30)));
  conf.events.add(Event(name="Automated co-evolution of GMF editor models", speaker="Davide Di Ruscio, Ralf Laemmel and Alfonso Pierantonio", abstract="The Eclipse Graphical Modeling (GMF) Framework provides the major approach for implementing visual languages on top of the Eclipse platform. GMF relies on a family of modeling languages to describe abstract syntax, concrete syntax as well as other aspects of the visual language and its implementation in an editor. GMF uses a model-driven approach to map the different GMF models to Java code. The framework, as it stands, lacks support for evolution. In particular, there is no support for propagating changes from the domain model (i.e., the abstract syntax of the visual language) to other editor models. We analyze the resulting co-evolution challenge, and we provide a solution by means of GMF model adapters, which automate the propagation of domain-model changes. These GMF model adapters are special model-to-model transformations that are driven by difference models for domain-model changes.", startDate=DateTime.create(2010, 9, 12, 16, 0)));
  conf.events.add(Event(name="An Extensive Catalog of Operators for the Coupled Evolution of Metamodels and Models", speaker="Markus Herrmannsdoerfer, Sander Vermolen and Guido Wachsmuth", abstract="Modeling languages and thus their metamodels are subject to change. When a metamodel is evolved, existing models may no longer conform to it. Manual migration of these models in response to metamodel evolution is tedious and error-prone. To significantly automate model migration, operator-based approaches provide reusable coupled operators that encapsulate both metamodel evolution and model migration. The success of an operator-based approach highly depends on the library of reusable coupled operators it provides. In this paper, we thus present an extensive catalog of coupled operators that is based both on a literature survey as well as real-life case studies. The catalog is organized according to a number of criteria to ease assessing the impact on models as well as selecting the right operator for a metamodel change at hand.", startDate=DateTime.create(2010, 9, 12, 16, 30)));
  conf.events.add(Event(name="JTL: a bidirectional and change propagating transformation language", speaker="Romina Eramo, Alfonso Pierantonio, Davide Di Ruscio and Antonio Cicchetti", abstract="In Model Driven Engineering bidirectional transformations are considered a core ingredient for managing both the consistency and synchronization of two or more related models. However, while non-bijectivity in bidirectional transformations is considered relevant, current languages still lack of a common understanding of its semantic implications hampering their applicability in practice. In this paper, the Janus Transformation Language (JTL) is presented, a bidirectional model transformation language specifically designed to support non-bijective transformations and change propagation. In particular, the language propagates changes occurring in a model to one or more related models according to the specified transformation regardless of the transformation direction. Additionally, whenever manual modifications let a model be non reachable anymore by a transformation, the closest model which approximate the ideal source one is inferred. The language semantics is also presented and its expressivity and applicability are validated against a reference benchmark. JTL is embedded in a framework available on the Eclipse platform which aims to facilitate the use of the approach, especially in the definition of model transformations.", startDate=DateTime.create(2010, 9, 12, 17, 0)));
  conf.events.add(Event(name="Dinner", startDate=DateTime.create(2010, 9, 12, 18, 0)));

  // Wednesday
  conf.events.add(Event(name="Keynote: Software Engineering and the Semantic Web - a match made in heaven or in hell?", speaker="Abraham Bernstein", abstract="The Semantic Web provides models and abstractions for the distributed processing of knowledge bases. In Software Engineering endeavors such capabilities are direly needed, for ease of implementation, maintenance, and software analysis. Conversely, software engineering has collected decades of experience in engineering large application frameworks containing both inheritance and aggregation. This experience could be of great use when, for example, thinking about the development of ontologies. These examples---and many others---seem to suggest that researchers from both fields should have a field day collaborating: On the surface this looks like a match made in heaven. But is that the case? This talk will explore the opportunities for cross-fertilization of the two research fields by presenting a set of concrete examples. In addition to the opportunities it will also try to identify cases of fools gold (pyrite), where the differences in method, tradition, or semantics between the two research fields may lead to a wild goose chase.", startDate=DateTime.create(2010, 9, 13, 9, 0)));
  conf.events.add(Event(name="Coffee", startDate=DateTime.create(2010, 9, 13, 10, 0)));
  conf.events.add(Event(name="A Unified Format for Language Documents", speaker="Vadim Zaytsev and Ralf Laemmel", abstract="We have analyzed a substantial number of language documentation artifacts, including language standards, language specifications, language reference manuals, as well as internal documents of standardization bodies. We have reverse-engineered their intended internal structure, and compared the results. The Language Document Format (LDF), was developed to specifically support the documentation domain. We have also integrated LDF into an engineering discipline for language documents including tool support, for example, for rendering language documents, extracting grammars and samples, and migrating existing documents into LDF. The definition of LDF, tool support for LDF, and LDF applications are freely available through SourceForge.", startDate=DateTime.create(2010, 9, 13, 10, 30)));
  conf.events.add(Event(name="Canonical method names for Java", speaker="Einar Host and Bjarte Ostvold", abstract="Programmers rely on the conventional meanings of method names when writing programs. However, these conventional meanings are implicit and vague, leading to various forms of ambiguity. This is problematic since it hurts the readability and maintainability of programs. Java programmers would benefit greatly from a more well-defined vocabulary. Identifying synonyms in the vocabulary of verbs used in method names is a step towards this goal. By rooting the meaning of verbs in the semantics of a large number of methods taken from real-world Java applications, we find that such synonyms can readily be identified. To support our claims, we demonstrate automatic identification of synonym candidates. This could be used as a starting point for a manual canonicalisation process, where redundant verbs are eliminated from the vocabulary.", startDate=DateTime.create(2010, 9, 13, 11, 0)));
  conf.events.add(Event(name="Subjective-C: Bringing Context to Mobile Platform Programming", speaker="Sebastian Gonzalez, Nicolas Cardozo, Kim Mens, Alfredo Cadiz, Jean-Christophe Libbrecht and Julien Goffaux", abstract="Thanks to steady advances in hardware, mobile computing platforms are nowadays much more connected to their physical and logical environment than ever before. To ease the construction of adaptable applications that are smarter with respect to their execution environment, the context-oriented programming paradigm has emerged. However, up until now there has been no proof that this emerging paradigm can be implemented and used effectively on mobile devices, probably the kind of platform which is most subject to dynamically changing contexts. In this paper we study how to effectively realise core context-oriented abstractions on top of Objective-C, a mainstream language for mobile device programming. The result is Subjective-C, a language which goes beyond currently existing context-oriented languages by providing a rich encoding of context interdependencies. Our initial validation cases and efficiency benchmarks make us confident that context-oriented programming can become mainstream in mobile application development.", startDate=DateTime.create(2010, 9, 13, 11, 30)));
  conf.events.add(Event(name="Lunch", startDate=DateTime.create(2010, 9, 13, 12, 0)));
  conf.events.add(Event(name="The Level-agnostic Modeling Language", speaker="Colin Atkinson, Bastian Kennel and Bjoern Goss", abstract="As an alternative modeling infrastructure and paradigm, multi-level modeling addresses many of the conceptual weaknesses found in the four level modeling infrastructure that underpins traditional modeling approaches like UML and EMF. It does this by explicitly distinguishing between linguistic and ontological forms of classification and by allowing the influence of classifiers to extend over more than one level of instantiation. Multi-level modeling is consequently starting to receive attention from a growing number of research groups. However, there has never been a concrete definition of a language designed from the ground-up for the specific purpose of representing multi-level models. Some authors have informally defined the \"look and feel\" of such a language, but to date there has been no systematic or fully elaborated definition of its concrete syntax. In this paper we address this problem by introducing the key elements of a language, known as the Level-Agnostic Modeling Language (LML) designed to support multi-level modeling.", startDate=DateTime.create(2010, 9, 13, 13, 30)));
  conf.events.add(Event(name="Debugging in Domain-Specific Modelling", speaker="Raphael Mannadiar and Hans Vangheluwe", abstract="An important obstacle to the wide-spread adoption of model-driven development approaches in industry is the lack of proper debugging facilities. Software debugging support is provided by a combination of language and Integrated Development Environment (IDE) features which enable the monitoring and altering of a running program's state. In Domain-Specific Modelling (DSM), debugging activities have a wider scope: designers debug model transformations (MTs) and synthesized artifacts, while domain-specific modellers debug their models, unaware of generated artifacts. This work surveys the state-of-the-art of debugging in the context of DSM and proposes a mapping between debugging concepts (e.g., breakpoints, assertions) in the software and DSM realms.", startDate=DateTime.create(2010, 9, 13, 13, 50)));
  conf.events.add(Event(name="COPE - A Workbench for the Coupled Evolution of Metamodels and Models", speaker="Markus Herrmannsdoerfer", abstract="Model-driven software development promises to increase productivity by offering modeling languages tailored to a problem domain. Consequently, an increasing number of modeling languages are built using metamodel-based language workbenches. In response to changing requirements and technologies, the modeling languages and thus their metamodels need to be adapted. Manual migration of existing models in response to metamodel adaptation is tedious and error-prone. In this paper, we present our tool COPE to automate the coupled evolution of metamodels and models. To not lose the intention behind the adaptation, COPE records the coupled evolution in an explicit history model. Based on this history model, COPE provides advanced tool support to inspect, refactor and recover the coupled evolution.", startDate=DateTime.create(2010, 9, 13, 14, 10)));
  conf.events.add(Event(name="DSLTrans: A Turing Incomplete Transformation Language", speaker="Bruno Barroca, Levi Lucio, Vasco Amaral, Roberto Felix and Vasco Sousa", abstract="In this paper we present DSLTrans: a visual language and a tool for model transformations[1]. We aim at tackling a couple of important challenges in model transformation languages --- transformation termination and confluence. The contribution of this paper is the proposition of a transformation language where all possible transformations are guaranteed to be terminating and confluent by construction. The resulting transformation language is simple, turing incomplete and includes transformation abstractions to support transformations in a software language engineering context. Our explanation of DSLTrans includes a complete formal description of our visual language and its properties.", startDate=DateTime.create(2010, 9, 13, 13, 30)));
  conf.events.add(Event(name="Translator generation using ART", speaker="Adrian Johnstone and Elizabeth Scott", abstract="ART (Ambiguity Resolved Translators) is a new translator generator tool which provides fast generalised parsing based on an extended GLL algorithm and automatic generation of tree traversers for manipulating abstract syntax. The input grammars to ART comprise modular sets of context free grammar rules, enhanced with regular expressions and annotations that describe disambiguation and tree modification operations using the TIF (Tear-Insert-Fold) formalism. ART generates a GLL parser for the input grammar along with an output grammar whose derivation trees are the abstract trees specified by the TIF tree modification operations.", startDate=DateTime.create(2010, 9, 13, 13, 50)));
  conf.events.add(Event(name="Empirical language analysis in software linguistics", speaker="Jean-Marie Favre, Dragan Gasevic, Ralf Laemmel and Ekaterina Pek", abstract="Software linguistics is the science of software languages. In this short paper, we sketch the general discipline of software linguistics, but our focus is on one part of it: empirical analysis of software languages. Such analysis is concerned with understanding language usage on the grounds of a corpus. In this short paper, we sketch a survey on empirical language analysis, and we argue that the research method of content analysis is needed for a thorough survey.", startDate=DateTime.create(2010, 9, 13, 14, 10)));
  conf.events.add(Event(name="Interactive Disambiguation of Meta Programs with Concrete Object Syntax", speaker="Lennart C. L. Kats, Karl T. Kalleberg and Eelco Visser", abstract="In meta-programming with concrete object syntax, meta programs can be written using the concrete syntax of manipulated programs. Quotations of concrete syntax fragments and anti-quotations for meta-level expressions and variables are used to manipulate the abstract representation of programs. These small, isolated fragments are often ambiguous and must be explicitly disambiguated with quotation tags or types, using names from the non-terminals of the object language syntax. Discoverability of these names has been an open issue, as they depend on the (grammar) implementation and are not part of the well-known concrete syntax of a language. Based on advances in interactive development environments, we introduce interactive disambiguation to address this issue, providing real-time feedback and proposing quick fixes in case of ambiguities.", startDate=DateTime.create(2010, 9, 13, 14, 30)));
  conf.events.add(Event(name="Break", startDate=DateTime.create(2010, 9, 13, 14, 50)));
  conf.events.add(Event(name="Evaluating a Textual Feature Modelling Language: Four Industrial Case Studies", speaker="Arnaud Hubaux, Quentin Boucher, Herman Hartmann, Rapha‘l Michel and Patrick Heymans", abstract="Feature models are commonly used in software product line engineering as a means to document variability. Since their introduction, feature models have been extended and formalised in various ways. The majority of these extensions are variants of the original tree-based graphical notation. But over time, textual dialects have also been proposed. The textual variability language (TVL) was proposed to combine the advantages of both graphical and textual notations. However, its benefits and limitations have not been empirically evaluated up to now. In this paper, we evaluate TVL with four cases from companies of different sizes and application domains. The study shows that practitioners can benefit from TVL. The participants appreciated the notation, the advantages of a textual language and considered the learning curve to be gentle. The study also reveals some limitations of the current version of TVL.", startDate=DateTime.create(2010, 9, 13, 15, 15)));
  conf.events.add(Event(name="Extending DMM Behavior Specifications for Visual Execution and Debugging	", speaker="Nils Bandener, Gregor Engels and Christian Soltenborn", abstract="Dynamic Meta Modeling (DMM) is a visual semantics specification technique targeted at behavioral languages equipped with a metamodel defining the language's abstract syntax. Given a model and a DMM specification, a transition system can be computed which represents the semantics of that model. It allows for the investigation of the model's behavior, e.g. for the sake of understanding the model's semantics or to verify that certain requirements are fulfilled. However, due to a number of reasons such as tooling and the size of the resulting transition systems, the manual inspection of the resulting transition system is cumbersome. One solution would be a visualization of the model's behavior using animated concrete syntax. In this paper, we show how we have enhanced DMM such that visual execution and debugging can be added to a language in a simple manner.", startDate=DateTime.create(2010, 9, 13, 15, 45)));
  conf.events.add(Event(name="Analysing the Cognitive Effectiveness of the BPMN 2.0 Visual Notation", speaker="Nicolas Genon, Patrick Heymans and Daniel Amyot", abstract="BPMN 2.0 is an OMG standard and one of the leading process modelling notations. Although the current language specification recognises the importance of defining a visual notation carefully, it does so by relying on common sense, intuition and emulation of common practices, rather than by adopting a rigorous scientific approach. This results in a number of suboptimal language design decisions that may impede effective model-mediated communication between stakeholders. We demonstrate and illustrate this by looking at BPMN 2.0 through the lens of the Physics of Notations, a collection of evidence-based principles that together form a theory of notation design. This work can be considered a first step towards making BPMN 2.0's visual notation more cognitively effective.", startDate=DateTime.create(2010, 9, 13, 16, 15)));
  conf.events.add(Event(name="Featherweight TeX and Parser Correctness", speaker="Sebastian Thore Erdweg and Klaus Ostermann", abstract="TeX (and its LaTeX incarnation) is a widely used document preparation system for technical and scientific documents. At the same time, TeX is also an unusual programming language with a quite powerful macro system. Despite the wide range of TeX users (especially in the scientific community), and despite a widely perceived considerable level of ``pain'' in using TeX, there is almost no research on TeX. This paper is an attempt to change that. To this end, we present Featherweight TeX, a formal model of TeX which we hope can play a similar role for TeX as Featherweight Java did for Java. The main technical problem which we study in terms of Featherweight TeX is the parsing problem. As for other dynamic languages performing syntactic analysis at runtime, the concept of ``static'' parsing and its correctness is unclear in TeX and shall be clarified in this paper. Moreover, it is the case that parsing TeX is impossible in general, but we present evidence that parsers for practical subsets exists. We furthermore outline three immediate applications of our formalization of TeX and its parsing: a macro debugger, an analysis that detects syntactic inconsistencies, and a test framework for TeX parsers.", startDate=DateTime.create(2010, 9, 13, 16, 45)));
  conf.events.add(Event(name="Closing", startDate=DateTime.create(2010, 9, 13, 17, 15)));
}